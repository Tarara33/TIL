# ＆
引数にブロックを受けとる時に使う。  
`(&引数名)`のようにする。  
~~~
def dice⭕️(&block)
  if block_given?
    yield
  else
    puts [1,2,3,4,5,6].sample
  end
end
---------------------------------

dice
=> 4

dice do 
  puts [7,8,9,10,11,12].sample
end
=> 9
~~~
***

# &:
ブロックタイプのメソッド(mapなど)の書き方を省略するときに使う。(条件あり)
「symbol-to-proc」と呼ぶ。  

`〇〇.ブロックタイプメソッド(&:メソッド名)` と使う。
***

## 使える条件
1. ブロックパラメーター(|n|とかのこと)が 1個だけである。
2. ブロックの中で呼び出すメソッドに引数がない。
3. ブロックの中ではブロックパラメーターに対してメソッドを 1回呼び出す以外の処理がない。

~~~
["A", "B", "C"].map{ |str| str.downcase }
=> ["a", "b", "c"]
~~~
この場合、  
- ブロックパラメーターは str 1一つである。
- downcaseメソッドには引数はいらない。
- mapメソッドの中で呼ぶのは downcase　1つである。

と条件が当てはまるので
~~~
["A", "B", "C"].map(&:downcase) 
=> ["a", "b", "c"]
~~~
と省略できる。(⚠️ &:にすると{}ではなく（）になる。)


これがもし以下のような場合は、条件2がクリアしないのでエラーになる。
~~~
["A", "B", "C"].map{ |str| puts str}
=> A
=> B
=> C

↓

["A", "B", "C"].map(&:puts)
=> エラー
~~~
***
