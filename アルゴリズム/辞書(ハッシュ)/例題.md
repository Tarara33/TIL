# 例題
p人のグループ A , q人のグループ B , r人のグループ C があります。  
各グループのメンバーにはそれぞれ番号がつけられており、   
A グループの i 番目の人は B グループの j 番目の人に仕事を任せ、  
B グループの j 番目の人は与えられた仕事を   
C グループの k 番目の人に任せます。  
すると結局、 A グループの i 番目の人の仕事をするのは C グループの k 番目の人だということになります。

パイザ君は A グループの各人の仕事を結局 C グループの誰が行うことになるのか知りたがっています。   
A グループの人のそれぞれが最終的に C グループの誰に仕事を頼むことになるのかを、   
A グループの人の番号が小さい順に p 行出力してください。

Aグループから仕事を頼まれた Bグループの人は必ずその仕事を Cグループの誰かに頼みます。   
Bグループに関する入力には⭕️「余計な」ものも含まれます。  
すなわち、 Aグループの誰からも仕事を頼まれていない Bグループの人に関して、  
その人が Cグループの誰に仕事を頼むかについての情報が与えられることもあります。

- 入力例1  
2 3 4  
1 3  
2 1  
2 3  
3 3  
1 4   

- 出力例1  
1 3  
2 4
~~~
p, q, r = gets.split(' ').map(&:to_i)
group_A, group_B, group_C = {}, {}, {}

# group_Aの {"Aグループの人" => "仕事頼む Bグループの人"}の組み合わせ hash作る
p.times do
  a,b = gets.split(' ').map(&:to_i)
  group_A[a] = b
end

# group_Bの {"Bグループの人" => "仕事頼む Cグループの人"}の組み合わせ hash作る
q.times do
  b, c = gets.split(' ').map(&:to_i)
  group_B[b] = c
end

# group_Cの {"Aグループの人" => "最終的に仕事頼んでる Cグループの人"}の組み合わせ ハッシュ作る。
p.times do |i| (⭕️Aグループの人の人数でいい、Bグループの人が頼んだ余計な仕事は入れない)
   ⭐️group_C[i + 1] = group_B[group_A[i + 1]]
end

⭐️今の所、それぞれのグループのハッシュは
group_A {1 => 3, 2 => 1}
group_B {2 => 3, 3 => 3, 1 => 4}

それを踏まえて順番に解くと
【ループ 1回目】
group_C[0 + 1] =  group_B[group_A[0 + 1]]
group_C[1] =  group_B[group_A[1]]
group_C[1] =  group_B[3]
group_C[1] =  3
つまり、Aグループの １さんの仕事は最終的に Cグループの ３さんに渡ってる。

【ループ 2回目】
group_C[1 + 1] =  group_B[group_A[1 + 1]]
group_C[2] =  group_B[group_A[2]]
group_C[2] =  group_B[1]
group_C[2] =  4
つまり、Aグループの 2さんの仕事は最終的に Cグループの 4さんに渡ってる。

つまり group_Cのハッシュは {1 => 3, 2 => 4} になる。

Aグループの番号を小さい順に並べるのは group_Cを作る時にすでにやってる。 (timesで　i = 0から作ってるので小さい順に並ぶ)
あとはこれを 「1 3」のような形で出す。

group_C.each do |val|
  puts val.join(' ')
end
~~~
***
  



