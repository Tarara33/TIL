# 条件
①ログアウトしてもブックマークが保存されている    
②ユーザーが同じ掲示板に対するブックマークが１つのみ    
③ブックマーク一覧ページでブックマークした投稿が見れる
④ブックマーク一覧のURLは「/boards/bookmarks」とする
***

# ブックマークモデルの作成
### 条件①    
ブラウザを閉じたりログアウトしても残したい（永続化させたい）ので、DBのテーブルにレコードとして残す形を取る。
~~~
$ rails g model Bookmark user:references board:references
~~~
***

### 条件②
ユーザーが同じ掲示板に対するブックマークが１つのみのバリデーションをDB側, モデル側で設定する。
~~~
DB側
[db/migrate/日付_cretae_bookmarks.rb]

class CreateBookmarks < ActiveRecord::Migration[5.2]
  def change
    create_table :bookmarks do |t|
      t.references :user, foreign_key: true, null: false
      t.references :board, foreign_key: true, null: false

      t.timestamps
    end
    
    add_index :bookmarks, [:user_id, :board_id], unique: true
    => ユーザーと掲示板の組み合わせが一意的ということ
      [user_id: 1, board_id: 1] = OK
      [user_id: 1, board_id: 2] = OK
      [user_id: 2, board_id: 2] = OK

  end
end
~~~
***

~~~
モデル側
[app/models/bookmark.rb]

class Bookmark < ApplicationRecord
  belongs_to :user
  belongs_to :board

  validates :user_id, uniqueness: {scope: :board_id}
  => これは　user_id の値に基づいて一意性を確保することを目的としているが、
　　　　  　　同時にその一意性の範囲を board_id の値に制限している。
    　　具体的には、同じ user_id を持つレコードが存在する場合、それらのレコードの中で board_id の値が異なっていたら有効とみなされる。

end
~~~
### ⭐️ scope (uniquenessのオプション)
validates :user_id, uniqueness: true　だと、    
同じ user_id はカラム内に存在できないため、ユーザーは一つの掲示板しかブックマークできない。    
validates :user_id, uniqueness: {scope: :board_id}とすると、    
一意性の範囲（scope）を、board_idに制限しているため、
user_id と board_id との組み合わせが一意性になっている。
***

# モデルのアソシエーション
- 一人のユーザーは複数のブックマークをつける    
- 一つの投稿は複数のブックマークをつけられる
~~~
[app/models/bookmark.rb]
class Bookmark < ApplicationRecord
  belongs_to :user
  belongs_to :board

  validates :user_id, uniqueness: {scope: :board_id}
end
~~~
***

~~~
[app/models/board.rb]
class Board < ApplicationRecord
  belongs_to :user
  has_many :comments, dependent: :destroy
  has_many :bookmarks, dependent: :destroy
end
~~~
***

~~~
[app/models/user.rb]
class User < ApplicationRecord
  authenticates_with_sorcery!
  has_many :boards, dependent: :destroy
  has_many :comments, dependent: :destroy
  has_many :bookmarks, dependent: :destroy
  has_many :bookmark_boards, through: :bookmarks, source: :board
end
~~~
***

### 条件③
ブックマーク一覧ページでブックマークした投稿が見れるようにするため、    
まず、「Userモデルのインスタンスから、ブックマークした、boardモデルへアクセス」できるようにする。
~~~
[app/models/user.rb]の
has_many :bookmark_boards, through: :bookmarks, source: :board
          (boardの別名）                                   （元のモデル名）

=> 同じ名前使って has_many :board, through: :bookmarks とすると上書きされるので別名つけてる。


NG！
has_many :bookmark_boards, through: :bookmarks
=> これだと、Userモデルインスタンスから、Bookmarkモデルのカラムにアクセスはできるが、
　　　　　　ブックマークしたBoardモデルのカラムへはできない。
　　　　　　例：user.bookmarks = OK
  　　　　　　　user.bookmark_boards = NG

OK!
has_many :bookmark_boards, through: :bookmarks, source: :board
=> これだとBookmarkテーブルを介してBoardテーブルへアクセスしているので、
  　　　user.bookmark_boards でエラーでない
~~~
***
もしも、ブックマークした投稿一覧だけではなく、    
この投稿にブックマークしたユーザー一覧も作るとしたらこれも記述。
~~~
[app/models/board.rb]
has_many :bookmark_users, through: :bookmarks, source: :user
~~~
***

### 💡「:bookmark_boards」はどこからきた？    
実際には bookmark_boards という名前のモデルを作成しているわけではなく、    
関連性の名前であり、関連するテーブルやモデルの操作を行うための便宜上の名前。    
この関連性を使用することで、さっき出てきた「user.bookmark_boards」のように、    
User モデルのインスタンスから bookmark_boards を呼び出すことができる。 
***

⚠️他のテーブル名使ってしまうと上書きされて元のコードが使えなくなってしまうので注意
~~~
has_many :boards, dependent: :destroy
has_many :bookmarks, dependent: :destroy
has_many :boards, through: :bookmarks, source: :board

=> 一行目の内容が上書きされてしまう
~~~
***

### ⭐️ source　オプション
別名でテーブル名つけた場合は sourceで元のテーブルを記述する。    
中間テーブルを介して参照する先のモデルを指定している。
***

# ブックマークコントローラーの作成
~~~
$ rails g controller bookmarks
~~~
アクションは    
- ブックマーク一覧を表示(index) 
- ブックマークを作る(create)    
- ブックマークを外す(destroy)
***

# routingの編集
bookmarksコントローラーのアクションは通常、特定のboardに関連付けられるものと考えるので、    
boardsコントローラーにネストさせる。
~~~
 resources :boards do
    resources :comments, only: %i[create], shallow: true
    resources :bookmarks, only: %i[create destroy], shallow: true
    => 特定のboardに対して、create, destroyアクションする
end
~~~
***

### 条件④.a
URLは「/boards/bookmarks」なので、        
bookmark一覧を取得する「bookmarks」というアクションをboardコントローラに作る。
⚠️bookmarkコントローラーにindexで作ると「/bookmarks」になる。
~~~
[app/controllers/board_controller.rb]

def bookmarks
    @favorites = current_user.bookmark_boards.includes(:user).order(created_at: :desc)
    => includesで(:user)を指定するのは、current_user.bookmark_boardsで、ユーザーがブックマークしたボードのコレクションを取得させるため。
  end
~~~
***

### 条件④.b
URLは「/boards/bookmarks」    
作ったbookmarksアクションをroutingで設定する。
~~~
resources :boards do
    resources :comments, only: %i[create], shallow: true
    resources :bookmarks, only: %i[create destroy], shallow: true
    get :bookmarks, on: :collection
    => 「/boards/bookmarks」でid必要ないのでcollection使う。
end
~~~
***

# ブックマークに関するメソッドを設定
ブックマーク操作はcurrent_userが行う操作なのでUserモデルに設定する。
~~~
[app/models/user.rb]

①def bookmark(board)
  bookmark_boards << board
end

②def unbookmark(board)
  bookmark_boards.destroy(board)
end

③def bookmark?(board)
  bookmark_boards.include?(board)
end
~~~
①引数で受け取った boardを bookmark_boardsという配列（またはコレクション）にboardを追加する操作。    
②引数で受け取った boardを bookmark_boardsという配列（またはコレクション）からを削除する操作。    
③引数で受け取った boardが bookmark_boardsという配列（またはコレクション）に含まれているかどうかを確認する操作。    
***

# ブックマークコントローラでアクション作成
~~~
[app/controllers/bookmarks_conntroller.rb]
class BookmarksController < ApplicationController

  def create
    board = Board.find(params[:id])
    current_user.bookmark(board)
    redirect_back fallback_location: root_path, success: t('boards.bookmarks.create')
  end

  def destroy
    board = current_user.bookmarks.find(params[:id])
    current_user.unbookmark(board)
    redirect_back fallback_location: root_path, success: t('boards.bookmarks.delete')
  end
end
~~~
⚠️viewファイルないので「@インスタンス変数」にしていない
***

### ⭐️redirect_back 
直前のページにリダイレクトする。    
戻せない場合の「`fallback_location:`」は必須。
~~~
redirect_back(fallback_location: HTTP_REFERERが設定されていない場合のリダイレクト先, allow_other_host: 許可されたHost=_allow_other_host, 引数..)
~~~
***
