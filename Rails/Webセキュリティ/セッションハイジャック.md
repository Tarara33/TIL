# セッションハイジャック
第三者がcookieの中身やセッションIDなどを盗聴して入手すると、そのユーザーとしてログイン出来てしまう。
***

## 対策
１. セキュリティに問題のあるネットワークを通過するcookieは盗聴可能です。   
無線LANはまさにそのようなネットワークの一例で、特に暗号化されていない無線LANでは、    
接続されているクライアントのすべてのトラフィックを簡単に傍聴できてしまう。   
よって、SSLによる安全な接続の提供が必要となるので
~~~
[アプリケーションの設定ファイル]
config.force_ssl = true
~~~
と記述する
***

2. 公共の端末での作業後にcookieを消去するような殊勝なユーザーはほとんどいない。    
最後のユーザーがWebアプリケーションからログアウトするのを忘れて立ち去っていたら、    
次のユーザーはそのWebアプリケーションをそのまま使えてしまう。    
ユーザーには必ずログアウトボタンを提供しなければならない。それもよく目立つボタンを。
***

# セッション固定攻撃
ユーザーのセッションIDを盗む代わりに、ユーザーのセッションIDを攻撃者が知っているセッションIDに固定（変更）するという方法。
***

## 対策
1.最も効果的な対応策は、ログイン成功後に古いセッションを無効にし、新しいセッションIDを発行すること。    
この対応策は、セッションハイジャックにも有効。
~~~
reset_session
~~~
を記述する（どこに？）    
また、ユーザー管理用にDeviseなどの有名なgemを導入していれば、ログイン・ログアウト時にセッションが自動的に切れるようになる。
***

2.セッションを失効させる    
cookieのタイムスタンプに有効期限を設定するのではなく、サーバー側でセッションを無効にする方が安全。    
たとえば次のようにSession.sweep("20.minutes")を呼ぶと、20分以上経過したセッションが失効する。
~~~
[多分モデルファイル]
class Session < ApplicationRecord
  def self.sweep(time = 1.hour)
    where(updated_at: ...time.ago).delete_all
  end
end
~~~
しかし例えば、攻撃者が5分おきにセッションを維持すると、サーバーがセッションを無効にしようとしてもセッションが恒久的に継続してしまう。    
その場合は
~~~
class Session < ApplicationRecord
  def self.sweep(time = 1.hour)
    where(updated_at: ...time.ago).or(where(created_at: ...2.days.ago)).delete_all
    => セッションされてから時間が過ぎたか、セッションを作成してから指定時間すぎたら消す。
  end
end
~~~
***

# 
