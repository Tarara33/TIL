# 見本
~~~
[spec/system.rb]
require "rails_helper"

describe "タスク管理機能", type: :system do
=> このタイプはテストのタイプ。ここではシステムテストタイプ。

  ⭕️let(:user_a) {FactoryBot.create(:user, name: "ユーザーA", email: "a@example.com")}
    let(:user_b) {FactoryBot.create(:user, name: "ユーザーB", email: "b@example.com")}
  ❗️let!(:task_a) {FactoryBot.create(:task, name: "最初のタスク", user: user_a)} #！強制で呼ぶ


  before do
    ⭕️FactoryBot .create (:task, name: '最初のタスク', user: user_a)
    visit login_path #ログイン画面にいく
    fill_in "メールアドレス", with: login_user.email #メアドうつ
    fill_in "パスワード", with: login_user.password#パスうつ
    click_button "ログインする" #ログインボタン押す
  end


  describe "一覧表示機能" do
=> 上で書いてるbeforeと同じ階層なのでこっちでも適応されてる。
    context "ユーザーAがログインしている時" do
      let(:login_user) {user_a}
      it_behaves_like "ユーザーAが作成したタスクが表示される"
        expect(page).to have_content ("最初のタスク")  
      end
...省略
~~~
***

# before
beforeの内容をおく階層によって共通化できる。
ここでのbeforeは同じ階層、下の階層で描かれるbeforeに使われる（共通）    
例では一覧機能表示のcontextで行うbefore（記入省略されてる）でvisit~からの処理される。
***

# let(){}
`let(定義名){定義の内容}`で定義できる
***

## let と let!
- letは定義した定数が初めて【使われた】ときに作成される。
- let!は各テストのブロック実行前に、定義した定数を作る。    
    

見本の流れで見ると、    
① ❗️の let!が作られる。    
② 最初のbefore doにある ⭕️部分（...user: user_a）で呼ばれたとき、⭕️のletが作られる。    
***

# describe "" do ~ end
大グループ分けのような感じ。    
テスト対象を書く。    
***

# context "" do ~ end
小グループ分けのような感じ。    
テスト対象のメソッドをどういう条件で実行するかを書く。    
正常系？異常系？のような感じ。
***

# it "" do ~ end
テスト実行時の期待値を書く。    
中に expectで実際に期待するコード書く。
***

# expect(期待する結果).to マッチャー

## 期待する結果
- 変数    
- (page)    
- (responce)    
など様々あるが、テストの種類によっては定義できないものもある。    
    
例えば、モデルスペックでは (page)は使えない。    
なぜなら（page)はブラウザに表示されてるか確認するやつ。      
システムスペックで使える。    
***

## マッチャー
[ココ](https://github.com/Tarara33/TIL/blob/main/Rails/Test/RSpec/%E3%83%9E%E3%83%83%E3%83%81%E3%83%A3%E3%83%BC.md)
***
