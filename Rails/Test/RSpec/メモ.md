# 実行するテストケースを限定する設定
spec_helper.rbの 50行目付近にある
~~~
[spec/spec_helper.rb]

=begin
  # This allows you to limit a spec run to individual examples or groups
  # you care about by tagging them with `:focus` metadata. When nothing
  # is tagged with `:focus`, all examples get run. RSpec also provides
  # aliases for `it`, `describe`, and `context` that include `:focus`
  # metadata: `fit`, `fdescribe` and `fcontext`, respectively.
⭕️config.filter_run_when_matching :focus
~~~
    
⭕️部分をコメントアウト外したいので、上にある「=begin」を動かす。
~~~
[spec/spec_helper.rb]

  # This allows you to limit a spec run to individual examples or groups
  # you care about by tagging them with `:focus` metadata. When nothing
  # is tagged with `:focus`, all examples get run. RSpec also provides
  # aliases for `it`, `describe`, and `context` that include `:focus`
  # metadata: `fit`, `fdescribe` and `fcontext`, respectively.
⭕️config.filter_run_when_matching :focus
=begin
~~~
***

## 使いかた
describe、content、itなどのテストブロックの頭に 「f」を付けるだけで、そのテストブロックのみが実行されるようになる。
~~~
RSpec.describe 'Users', type: :system do
  describe 'ログイン前' do
    describe 'ユーザー新規登録' do
      context 'フォームの入力値が正常' do
        it 'ユーザーの新規作成が成功する' do
          # テストは省略
        end
      end
      context 'メールアドレスが未入力' do
          # 実行したいテストブロックに f をつける。
        ⭕️fit 'ユーザーの新規作成が失敗する' do
          # テストは省略
        end
      end
~~~
***

# 実行画面を見やすくする
~~~
[.rspec]
--format documentation
~~~
通常は...でテスト通過がわかるが、
[![Image from Gyazo](https://i.gyazo.com/a128f249804dcbdce42392c327ae293e.png)](https://gyazo.com/a128f249804dcbdce42392c327ae293e)  
    
describeや context、itの文章が入って見やすくなる。    
[![Image from Gyazo](https://i.gyazo.com/902215d1f36479312b48dbfd2c146a8c.png)](https://gyazo.com/902215d1f36479312b48dbfd2c146a8c)    
***

# テスト内での変数
~~~
context '登録済のメールアドレスを使用' do
  before do
    user = create(:user)
  end
  it 'ユーザーの新規作成が失敗する' do
    visit sign_up_path
    fill_in 'Email', with: user.email
~~~
例えばこのようなコードの時、先に 変数userを作成して、itの中で user.emailとするとエラーが出る。    
なぜなら、変数はブロック(before do~endなど)を超えて使えないため。    
⭐️ ブロック超えて使いたいなら、インスタンス変数にする。
~~~
context '登録済のメールアドレスを使用' do
  before do
    @user = create(:user)
  end
  it 'ユーザーの新規作成が失敗する' do
    visit sign_up_path
    fill_in 'Email', with: @user.email
~~~
***

# rails c はサンドボックスモードで
例えば、このようなFactoryBotファイルを設定して、    
そのデーターを確認したくて rails cで入力すると、
~~~
[spec/factries/user.rb]
FactoryBot.define do
  factory :user do
    sequence(:email) { |n| "user_#{n}@example.com" }
    password {'password'}
    password_confirmation {'password'}
  end
end


[rails c]
$ user = FactoryBot.craete(:user)
=> => #<User:0x0000000108e233b8
 id: 3,
 email: "user_1@example.com",
 crypted_password:...
~~~
実際にデータベースにコレが登録されてしまう。    
    
そして exitしてもう一度同じことをすると、    
FactoryBotはまた「user_1@example.com」から作ろうとするので、    
emailにユニーク制度かけていた場合、そのemailは存在しますとエラーが出る。    
    
無駄にテストデータも増えてしまうし、テストが動かなくなったり厄介なので    
基本的にRspecのデーターはデータベースに登録しない。    
そのためサンドボックスモードにする。
***

# テストが通らない
一つ目のテストは通ったのに二つ目が通らなかった。    
しかしその二つの違いはemailがちゃんと入力してるか or してないかの違いのみで visitするパスは一緒だった。    
エラーの内容は
~~~
 Failure/Error: visit sign_up_path #一つ目の visitは平気で二つ目ダメなことある？？
     
     TypeError:
       no implicit conversion from nil to integer
~~~
結局、上に WARINGで出てた  Net::ProtocRetryErrorを gem 'net-http'インストールしたら通るようになった。    
こんなこともあるので、コードのせいだけじゃな行こともあると知った。
***

# デバック
テストでもデバックできる。
~~~
      it 'Project詳細からTask一覧ページにアクセスした場合、Taskが表示されること' do
        # FIXME: テストが失敗するので修正してください
        visit project_path(project)
        click_link 'View Todos'
        byebug
        expect(find('.task_list')).to have_content task.title
        expect(Task.count).to eq 1
        expect(current_path).to eq project_tasks_path(project)
      end
    end
  end
~~~
こんな感じで「byebug」入れてテスト実行すると
~~~
[16, 25] in /Users/sarina/workspace/runteq/rails_spec/rspec_app_exam/spec/system/task_spec.rb
   16:       it 'Project詳細からTask一覧ページにアクセスした場合、Taskが表示されること' do
   17:         # FIXME: テストが失敗するので修正してください
   18:         visit project_path(project)
   19:         click_link 'View Todos'
   20:         byebug
=> 21:         expect(find('.task_list')).to have_content task.title
   22:         expect(Task.count).to eq 1
   23:         expect(current_path).to eq project_tasks_path(project)
   24:       end
   25:     end
(byebug) click_link 
*** Capybara::Ambiguous Exception: Ambiguous match, found 3 elements matching visible link nil　　#capybaraがどこクリックしていいのか分からないと返信

nil
(byebug) click_link 'View Todos'
#<Capybara::Node::Element tag="a" path="/HTML/BODY[1]/P[5]/A[1]">  #指定してるクリックする場所 capybara見つけた
(byebug) expect(Task.count).to eq 1
true
~~~~
⚠️ byebugはエラーの出てるコードの下に入れてしまうと、実行されずに無視される。(テストがそこで止まってしまうため)    
なので、エラーのでてる前に入れる！
***

# 現在の開いてるページが見たい！
- `save_and_open_page` を使う。    
- gem 'launchy'入れる。    
~~~
visit project_path(project)
        save_and_open_page

=> パスに移動した後のページでブラウザ開いてくれる。
~~~
***

# 別タブをテストする方法
クリックしたら別タブが開かれて、そこのページで expectしたい場合、これらを使う。    
    
- switch_to_window(windows.last)...最後に開いたタブに移動    
- switch_to_window(windows.second)...二つ目のタブに移動    
~~~
[修正前]
it 'Project詳細からTask一覧ページにアクセスした場合、Taskが表示されること' do
  # FIXME: テストが失敗するので修正してください
  visit project_path(project)
  click_link 'View Todos'
  expect(find('.task_list')).to have_content task.title
end
=>  クリックしたら別タブ開くが、このままだとそのままのタブでexpect探してるので、テスト通らない。


[修正後]
it 'Project詳細からTask一覧ページにアクセスした場合、Taskが表示されること' do
  # FIXME: テストが失敗するので修正してください
  visit project_path(project)
  click_link 'View Todos'
  switch_to_window(windows.last)
  expect(find('.task_list')).to have_content task.title
end
=> クリック後は別タブをテストも追いかけるのでそちらで expect探してるので、テスト通る。
~~~
***
